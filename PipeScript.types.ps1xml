<?xml version="1.0" encoding="utf-16"?>
<!-- Generated with EZOut 1.8.7: Install-Module EZOut or https://github.com/StartAutomating/EZOut -->
<Types>
  <Type>
    <Name>System.Management.Automation.Language.Ast</Name>
    <Members>
      <ScriptMethod>
        <Name>ConvertFromAST</Name>
        <Script>
                        param()

return $this

                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>GetLineage</Name>
        <Script>
                        $thisParent = $this.Parent
while ($thisParent) {
    $thisParent
    $thisParent  = $thisParent.Parent
}

                    </Script>
      </ScriptMethod>
    </Members>
  </Type>
  <Type>
    <Name>System.Management.Automation.Language.AttributeAst</Name>
    <Members>
      <ScriptProperty>
        <Name>ArgumentList</Name>
        <GetScriptBlock>
                        $Parameter    = [Ordered]@{}
$ArgumentList = @()
# Collect all of the arguments of the attribute, in the order they were specified.
$argsInOrder = @(
    @($this.PositionalArguments) + @($this.NamedArguments) | 
    Sort-Object { $_.Extent.StartOffset}
)


# Now we need to map each of those arguments into either named or positional arguments.
foreach ($attributeArg in $argsInOrder) {
    # Named arguments are fairly straightforward:                                
    if ($attributeArg -is [Management.Automation.Language.NamedAttributeArgumentAst]) {
        $argName = $attributeArg.ArgumentName
        $argAst  = $attributeArg.Argument
        $parameter[$argName] =
            if ($argName -eq $argAst) { # If the argument is the name,
                $true # treat it as a [switch] parameter.
            }
            # If the argument value was an ScriptBlockExpression
            else {
                $argAst
            }                        
    } else {
        # If we are a positional parameter, for the moment:
        if ($parameter.Count) {
            # add it to the last named parameter.
            $parameter[@($parameter.Keys)[-1]] = 
                @() + $parameter[@($parameter.Keys)[-1]] + $argAst
        } else {
            # Or add it to the list of string arguments.
            $ArgumentList += 
                $attributeArg.ConvertFromAst()                            
        }
    }
}

return $ArgumentList

                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Parameter</Name>
        <GetScriptBlock>
                        $Parameter    = [Ordered]@{}
# Collect all of the arguments of the attribute, in the order they were specified.
$argsInOrder = @(
    @($this.PositionalArguments) + @($this.NamedArguments) | 
    Sort-Object { $_.Extent.StartOffset}
)

# Now we need to map each of those arguments into either named or positional arguments.
foreach ($attributeArg in $argsInOrder) {
    # Named arguments are fairly straightforward:                                
    if ($attributeArg -is [Management.Automation.Language.NamedAttributeArgumentAst]) {
        $argName = $attributeArg.ArgumentName
        $argAst  = $attributeArg.Argument
        $parameter[$argName] =
            if ($argName -eq $argAst) { # If the argument is the name,
                $true # treat it as a [switch] parameter.
            }
            # If the argument value was an ScriptBlockExpression
            else {
                $argAst.ConvertFromAst()
            }
    } else {
        # If we are a positional parameter, for the moment:
        if ($parameter.Count) {
            # add it to the last named parameter.
            $parameter[@($parameter.Keys)[-1]] = 
                @() + $parameter[@($parameter.Keys)[-1]] + $attributeArg.ConvertFromAst()
        }
    }
}

return $Parameter
                    </GetScriptBlock>
      </ScriptProperty>
    </Members>
  </Type>
  <Type>
    <Name>System.Management.Automation.Language.CommandAst</Name>
    <Members>
      <ScriptProperty>
        <Name>ArgumentList</Name>
        <GetScriptBlock>
                        $parameterAstType  = [Management.Automation.Language.CommandParameterAst]
@(
for (
    $commandElementIndex = 1
    $commandElementIndex -lt $this.CommandElements.Count
    $commandElementIndex++
)
{
    $commandElement = $this.CommandElements[$commandElementIndex]
    $nextElement    = $this.CommandElements[$commandElementIndex + 1]
    if ($commandElement -is $parameterAstType) {
        if (-not $commandElement.Argument -and
            $nextElement -and 
            $nextElement -isnot $parameterAstType)  {
            $commandElementIndex++
        }
    } else {
        $commandElement.ConvertFromAst()  
    }    
}
)
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>IsPiped</Name>
        <GetScriptBlock>
                        ($this.Parent -is [Management.Automation.Language.PipelineAst]) -and
($this.Parent.PipelineElements.Count -gt 1)

                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Parameter</Name>
        <GetScriptBlock>
                        $NamedParameters = [Ordered]@{}
$parameterAstType = [Management.Automation.Language.CommandParameterAst]

for (
    $commandElementIndex = 1
    $commandElementIndex -lt $this.CommandElements.Count
    $commandElementIndex++
)
{
    $commandElement = $this.CommandElements[$commandElementIndex]
    $nextElement    = $this.CommandElements[$commandElementIndex + 1]
    if ($commandElement -is $parameterAstType) {
        if ($commandElement.Argument) {            
            $NamedParameters[$commandElement.ParameterName] =                 
                $commandElement.Argument.ConvertFromAst()
        } elseif ($nextElement -and $nextElement -isnot $parameterAstType)  {
            $NamedParameters[$commandElement.ParameterName] = 
                $nextElement.Argument.ConvertFromAst()
            $commandElementIndex++
        } else {
            $NamedParameters[$commandElement.ParameterName] = $true
        }
    }
}

$NamedParameters
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>PipelineLength</Name>
        <GetScriptBlock>
                        if ($this.Parent -isnot [Management.Automation.Language.PipelineAst]) { return $null }
$this.Parent.PipelineElements.Count



                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>PipelinePosition</Name>
        <GetScriptBlock>
                        if ($this.Parent -isnot [Management.Automation.Language.PipelineAst]) { return $null }
$this.Parent.PipelineElements.IndexOf($this)


                    </GetScriptBlock>
      </ScriptProperty>
    </Members>
  </Type>
  <Type>
    <Name>System.Management.Automation.Language.ConstantExpressionAst</Name>
    <Members>
      <ScriptMethod>
        <Name>ConvertFromAST</Name>
        <Script>
                        $this.Value

                    </Script>
      </ScriptMethod>
    </Members>
  </Type>
  <Type>
    <Name>PipeScript</Name>
    <Members>
      <ScriptProperty>
        <Name>PipeScriptType</Name>
        <GetScriptBlock>
                        if ($this.Source -match '\.psx\.ps1{0,1}$') {
    "Transpiler"
}
elseif ($this.Source -match "\.ps1{0,1}\.(?&lt;ext&gt;[^.]+$)") {
    "SourceGenerator"
}
elseif ($this.Source) {
    "PipeScriptFile"
}
else {
    "Function"
}

                    </GetScriptBlock>
      </ScriptProperty>
    </Members>
  </Type>
  <Type>
    <Name>System.Management.Automation.ScriptBlock</Name>
    <Members>
      <ScriptMethod>
        <Name>Transpile</Name>
        <Script>
                        $this | .&gt;PipeScript

                    </Script>
      </ScriptMethod>
    </Members>
  </Type>
  <Type>
    <Name>System.Management.Automation.Language.ScriptBlockExpressionAst</Name>
    <Members>
      <ScriptMethod>
        <Name>ConvertFromAST</Name>
        <Script>
                        $this.GetScriptBlock()

                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>GetScriptBlock</Name>
        <Script>
                        [ScriptBlock]::create($this -replace '^\{' -replace '\}$')

                    </Script>
      </ScriptMethod>
    </Members>
  </Type>
  <Type>
    <Name>System.Management.Automation.Language.ScriptBlockAst</Name>
    <Members>
      <ScriptMethod>
        <Name>ConvertFromAST</Name>
        <Script>
                        $this.GetScriptBlock()

                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>GetScriptBlock</Name>
        <Script>
                        [ScriptBlock]::create($this -replace '^\{' -replace '\}$')

                    </Script>
      </ScriptMethod>
    </Members>
  </Type>
  <Type>
    <Name>System.Management.Automation.Language.VariableExpressionAst</Name>
    <Members>
      <ScriptMethod>
        <Name>ConvertFromAST</Name>
        <Script>
                        # Most variables we will not know the value of until we have run.
# the exceptions to the rule are:  $true, $false, and $null
if ($this.variablePath.userPath -in 'true', 'false', 'null') {
    $ExecutionContext.SessionState.PSVariable.Get($this.variablePath).Value
} else {
    $this
}

                    </Script>
      </ScriptMethod>
    </Members>
  </Type>
</Types>
